"""
EJERCICIO 1.3: SISTEMA DE PR√âSTAMOS Y DEVOLUCIONES
"""

from datetime import datetime, timedelta

class Transaccion:
    def __init__(self, id_transaccion, usuario, material):
        self.__id_transaccion = id_transaccion
        self.__fecha = datetime.now()
        self.__usuario = usuario
        self.__material = material
        self._estado = "pendiente"
    
    def get_id_transaccion(self):
        return self.__id_transaccion
    
    def get_fecha(self):
        return self.__fecha
    
    def get_usuario(self):
        return self.__usuario
    
    def get_material(self):
        return self.__material
    
    def get_estado(self):
        return self._estado
    
    def set_estado(self, estado):
        estados_validos = ["pendiente", "aprobada", "rechazada", "completada", "cancelada"]
        if estado not in estados_validos:
            raise ValueError(f"Estado inv√°lido. V√°lidos: {estados_validos}")
        self._estado = estado
    
    def procesar_transaccion(self):
        raise NotImplementedError("M√©todo debe implementarse")
    
    def calcular_costo(self):
        raise NotImplementedError("M√©todo debe implementarse")
    
    def __str__(self):
        return f"{self.__class__.__name__} {self.__id_transaccion} - {self._estado}"

class Prestamo(Transaccion):
    def __init__(self, id_transaccion, usuario, material, fecha_inicio=None):
        super().__init__(id_transaccion, usuario, material)
        self.__fecha_inicio = fecha_inicio if fecha_inicio else datetime.now()
        self.__fecha_limite = self.__fecha_inicio + timedelta(days=usuario.calcular_dias_prestamo())
        self.__fecha_devolucion_real = None
        self.__dias_retraso = 0
    
    def procesar_transaccion(self):
        if self._estado == "pendiente":
            if self.__usuario.agregar_prestamo(self.__material):
                self.set_estado("aprobada")
                return True
            else:
                self.set_estado("rechazada")
                return False
        return False
    
    def calcular_costo(self):
        dias = (self.__fecha_limite - self.__fecha_inicio).days
        costo_base = self.__material.calcular_valor_prestamo(dias)
        multa = self._calcular_multa()
        return costo_base + multa
    
    def _calcular_multa(self):
        if self.__fecha_devolucion_real and self.__fecha_devolucion_real > self.__fecha_limite:
            self.__dias_retraso = (self.__fecha_devolucion_real - self.__fecha_limite).days
            return self.__dias_retraso * 0.50
        return 0
    
    def registrar_devolucion(self, fecha_devolucion=None):
        if not fecha_devolucion:
            fecha_devolucion = datetime.now()
        
        self.__fecha_devolucion_real = fecha_devolucion
        self.set_estado("completada")
        
        # Buscar y marcar pr√©stamo como devuelto en el usuario
        for prestamo in self.__usuario.get_historial_prestamos():
            if prestamo['material'] == self.__material and not prestamo['devuelto']:
                prestamo['devuelto'] = True
                break
        
        multa = self._calcular_multa()
        return multa
    
    def get_fecha_inicio(self):
        return self.__fecha_inicio
    
    def get_fecha_limite(self):
        return self.__fecha_limite
    
    def get_fecha_devolucion_real(self):
        return self.__fecha_devolucion_real
    
    def get_dias_retraso(self):
        return self.__dias_retraso
    
    def __str__(self):
        return f"{super().__str__()} | {self.__material.get_titulo()[:15]}..."

class Renovacion(Transaccion):
    def __init__(self, id_transaccion, usuario, material, prestamo_original):
        super().__init__(id_transaccion, usuario, material)
        self.__prestamo_original = prestamo_original
        self.__nueva_fecha_limite = prestamo_original.get_fecha_limite() + timedelta(days=7)
    
    def procesar_transaccion(self):
        if self._estado == "pendiente":
            # Verificar que no haya multas pendientes
            if self.__prestamo_original.get_dias_retraso() > 0:
                print("‚ùå No se puede renovar con multa pendiente")
                self.set_estado("rechazada")
                return False
            
            # Actualizar fecha l√≠mite del pr√©stamo original
            self.__prestamo_original._Prestamo__fecha_limite = self.__nueva_fecha_limite
            self.set_estado("aprobada")
            return True
        return False
    
    def calcular_costo(self):
        # 50% de descuento sobre el costo original
        costo_original = self.__prestamo_original.calcular_costo()
        return costo_original * 0.50
    
    def get_prestamo_original(self):
        return self.__prestamo_original
    
    def get_nueva_fecha_limite(self):
        return self.__nueva_fecha_limite
    
    def __str__(self):
        return f"{super().__str__()} hasta {self.__nueva_fecha_limite.strftime('%d/%m')}"

class Reserva(Transaccion):
    def __init__(self, id_transaccion, usuario, material, fecha_reserva=None):
        super().__init__(id_transaccion, usuario, material)
        self.__fecha_reserva = fecha_reserva if fecha_reserva else datetime.now()
        self.__fecha_retiro_estimada = self.__fecha_reserva + timedelta(days=2)
        self.__activa = True
    
    def procesar_transaccion(self):
        if self._estado == "pendiente":
            self.set_estado("aprobada")
            return True
        return False
    
    def calcular_costo(self):
        return 0  # Las reservas son gratuitas
    
    def cancelar_reserva(self):
        self.__activa = False
        self.set_estado("cancelada")
    
    def get_fecha_reserva(self):
        return self.__fecha_reserva
    
    def get_fecha_retiro_estimada(self):
        return self.__fecha_retiro_estimada
    
    def esta_activa(self):
        return self.__activa
    
    def __str__(self):
        estado = "activa" if self.__activa else "cancelada"
        return f"{super().__str__()} ({estado})"

class Devolucion(Transaccion):
    def __init__(self, id_transaccion, usuario, material, prestamo_asociado, estado_material="bueno"):
        super().__init__(id_transaccion, usuario, material)
        self.__prestamo_asociado = prestamo_asociado
        self.__fecha_devolucion = datetime.now()
        self.__estado_material = estado_material
        self.__tiene_multa = False
    
    def procesar_transaccion(self):
        if self._estado == "pendiente":
            multa = self.__prestamo_asociado.registrar_devolucion(self.__fecha_devolucion)
            self.__tiene_multa = multa > 0
            self.set_estado("completada")
            return True
        return False
    
    def calcular_costo(self):
        if self.__tiene_multa:
            return self.__prestamo_asociado.get_dias_retraso() * 0.50
        return 0
    
    def get_fecha_devolucion(self):
        return self.__fecha_devolucion
    
    def get_estado_material(self):
        return self.__estado_material
    
    def set_estado_material(self, estado):
        estados_validos = ["excelente", "bueno", "regular", "malo", "da√±ado"]
        if estado not in estados_validos:
            raise ValueError(f"Estado inv√°lido. V√°lidos: {estados_validos}")
        self.__estado_material = estado
    
    def tiene_multa(self):
        return self.__tiene_multa
    
    def __str__(self):
        multa = "con multa" if self.__tiene_multa else "sin multa"
        return f"{super().__str__()} ({multa})"

# ========== MEN√ö INTERACTIVO ==========
class MenuTransacciones:
    def __init__(self):
        self.transacciones = []
        self.usuarios = []
        self.materiales = []
        self.cargar_datos_ejemplo()
    
    def cargar_datos_ejemplo(self):
        """Carga datos de ejemplo de ejercicios anteriores"""
        try:
            # Importar clases de ejercicios anteriores
            from ejercicio_1_1_menu import LibroFisico, LibroElectronico
            from ejercicio_1_2_menu import Estudiante, Profesor
            
            # Crear materiales de ejemplo
            self.materiales = [
                LibroFisico("Python Avanzado", "Autor Python", 2023, 
                           "PYT001", 350, "Editorial Tec", "excelente"),
                LibroElectronico("Clean Code", "Robert Martin", 2008,
                                "CC001", 3.8, "EPUB", "https://ejemplo.com")
            ]
            
            # Crear usuarios de ejemplo
            self.usuarios = [
                Estudiante("Ana Estudiante", "EST123", "ana@edu.com", 
                          "Inform√°tica", 6),
                Profesor("Dr. Profesor", "PROF456", "profesor@edu.com", 
                        "Ciencias")
            ]
            
            # Crear algunas transacciones de ejemplo
            if self.usuarios and self.materiales:
                prestamo = Prestamo("P001", self.usuarios[0], self.materiales[0])
                prestamo.procesar_transaccion()
                self.transacciones.append(prestamo)
                
                reserva = Reserva("R001", self.usuarios[1], self.materiales[1])
                reserva.procesar_transaccion()
                self.transacciones.append(reserva)
                
        except ImportError:
            print("‚ö†Ô∏è  Advertencia: No se pudieron cargar datos de ejemplo")
            print("   Ejecute primero los ejercicios 1.1 y 1.2")
    
    def mostrar_menu_principal(self):
        print("\n" + "="*60)
        print("üíº SISTEMA DE PR√âSTAMOS Y DEVOLUCIONES")
        print("="*60)
        print("1. üìñ Crear nuevo pr√©stamo")
        print("2. üîÑ Crear renovaci√≥n")
        print("3. üïê Crear reserva")
        print("4. üìÖ Registrar devoluci√≥n")
        print("5. üëÄ Ver todas las transacciones")
        print("6. üí∞ Calcular costos y multas")
        print("7. üéØ Demostrar polimorfismo")
        print("8. üîí Demostrar encapsulamiento")
        print("9. üìä Simular ciclo completo")
        print("0. üö™ Salir")
        print("-"*60)
    
    def obtener_entrada(self, mensaje, tipo=str):
        while True:
            try:
                entrada = input(f"{mensaje}: ").strip()
                if tipo == int:
                    return int(entrada)
                elif tipo == float:
                    return float(entrada)
                return entrada
            except ValueError:
                print("‚ùå Entrada inv√°lida. Intente nuevamente.")
    
    def seleccionar_usuario(self):
        if not self.usuarios:
            print("‚ùå No hay usuarios disponibles")
            return None
        
        print("\n--- SELECCIONAR USUARIO ---")
        for i, usuario in enumerate(self.usuarios, 1):
            print(f"{i}. {usuario}")
        
        try:
            opcion = self.obtener_entrada("Seleccione usuario", int) - 1
            if 0 <= opcion < len(self.usuarios):
                return self.usuarios[opcion]
        except (ValueError, IndexError):
            print("‚ùå Opci√≥n inv√°lida")
        
        return None
    
    def seleccionar_material(self):
        if not self.materiales:
            print("‚ùå No hay materiales disponibles")
            return None
        
        print("\n--- SELECCIONAR MATERIAL ---")
        for i, material in enumerate(self.materiales, 1):
            print(f"{i}. {material}")
        
        try:
            opcion = self.obtener_entrada("Seleccione material", int) - 1
            if 0 <= opcion < len(self.materiales):
                return self.materiales[opcion]
        except (ValueError, IndexError):
            print("‚ùå Opci√≥n inv√°lida")
        
        return None
    
    def seleccionar_prestamo(self):
        prestamos = [t for t in self.transacciones if isinstance(t, Prestamo)]
        
        if not prestamos:
            print("‚ùå No hay pr√©stamos disponibles")
            return None
        
        print("\n--- SELECCIONAR PR√âSTAMO ---")
        for i, prestamo in enumerate(prestamos, 1):
            print(f"{i}. {prestamo}")
        
        try:
            opcion = self.obtener_entrada("Seleccione pr√©stamo", int) - 1
            if 0 <= opcion < len(prestamos):
                return prestamos[opcion]
        except (ValueError, IndexError):
            print("‚ùå Opci√≥n inv√°lida")
        
        return None
    
    def crear_prestamo(self):
        print("\n" + "="*40)
        print("üìñ CREAR NUEVO PR√âSTAMO")
        print("="*40)
        
        usuario = self.seleccionar_usuario()
        if not usuario:
            return
        
        material = self.seleccionar_material()
        if not material:
            return
        
        id_trans = self.obtener_entrada("ID de transacci√≥n (ej: P002)")
        
        try:
            prestamo = Prestamo(id_trans, usuario, material)
            if prestamo.procesar_transaccion():
                self.transacciones.append(prestamo)
                print(f"\n‚úÖ PR√âSTAMO APROBADO")
                print(f"   ID: {prestamo.get_id_transaccion()}")
                print(f"   Usuario: {usuario.get_nombre()}")
                print(f"   Material: {material.get_titulo()}")
                print(f"   Fecha l√≠mite: {prestamo.get_fecha_limite().strftime('%d/%m/%Y')}")
                print(f"   Costo estimado: ${prestamo.calcular_costo():.2f}")
            else:
                print("‚ùå PR√âSTAMO RECHAZADO")
                print("   Posibles causas:")
                print("   ‚Ä¢ Usuario alcanz√≥ su l√≠mite de pr√©stamos")
                print("   ‚Ä¢ Material no disponible")
        except Exception as e:
            print(f"‚ùå Error: {e}")
    
    def crear_renovacion(self):
        print("\n" + "="*40)
        print("üîÑ CREAR RENOVACI√ìN")
        print("="*40)
        
        prestamo = self.seleccionar_prestamo()
        if not prestamo:
            return
        
        id_trans = self.obtener_entrada("ID de renovaci√≥n (ej: REN001)")
        
        try:
            renovacion = Renovacion(id_trans, prestamo.get_usuario(), 
                                   prestamo.get_material(), prestamo)
            
            if renovacion.procesar_transaccion():
                self.transacciones.append(renovacion)
                print(f"\n‚úÖ RENOVACI√ìN APROBADA")
                print(f"   Pr√©stamo original: {prestamo.get_id_transaccion()}")
                print(f"   Nueva fecha l√≠mite: {renovacion.get_nueva_fecha_limite().strftime('%d/%m/%Y')}")
                print(f"   Costo con 50% descuento: ${renovacion.calcular_costo():.2f}")
            else:
                print("‚ùå RENOVACI√ìN RECHAZADA")
                print("   Posibles causas:")
                print("   ‚Ä¢ Hay multas pendientes")
                print("   ‚Ä¢ Pr√©stamo no est√° activo")
        except Exception as e:
            print(f"‚ùå Error: {e}")
    
    def crear_reserva(self):
        print("\n" + "="*40)
        print("üïê CREAR RESERVA")
        print("="*40)
        
        usuario = self.seleccionar_usuario()
        if not usuario:
            return
        
        material = self.seleccionar_material()
        if not material:
            return
        
        id_trans = self.obtener_entrada("ID de reserva (ej: RES002)")
        
        try:
            reserva = Reserva(id_trans, usuario, material)
            if reserva.procesar_transaccion():
                self.transacciones.append(reserva)
                print(f"\n‚úÖ RESERVA CREADA")
                print(f"   ID: {reserva.get_id_transaccion()}")
                print(f"   Usuario: {usuario.get_nombre()}")
                print(f"   Material: {material.get_titulo()}")
                print(f"   Fecha retiro estimada: {reserva.get_fecha_retiro_estimada().strftime('%d/%m/%Y')}")
                print(f"   Costo: ${reserva.calcular_costo():.2f} (gratis)")
            else:
                print("‚ùå NO SE PUDO CREAR LA RESERVA")
        except Exception as e:
            print(f"‚ùå Error: {e}")
    
    def registrar_devolucion(self):
        print("\n" + "="*40)
        print("üìÖ REGISTRAR DEVOLUCI√ìN")
        print("="*40)
        
        prestamo = self.seleccionar_prestamo()
        if not prestamo:
            return
        
        # Verificar que el pr√©stamo no est√© ya devuelto
        if prestamo.get_fecha_devolucion_real():
            print("‚ùå Este pr√©stamo ya fue devuelto")
            return
        
        print("\nüíø ESTADO DEL MATERIAL:")
        print("1. Excelente (como nuevo)")
        print("2. Bueno (uso normal)")
        print("3. Regular (se√±ales de uso)")
        print("4. Malo (da√±os menores)")
        print("5. Da√±ado (requiere reparaci√≥n)")
        
        try:
            opcion = self.obtener_entrada("Seleccione estado", int)
            estados = ["excelente", "bueno", "regular", "malo", "da√±ado"]
            estado = estados[opcion-1] if 1 <= opcion <= 5 else "bueno"
        except:
            estado = "bueno"
        
        # Preguntar si hay retraso
        print("\n‚è∞ ¬øHay retraso en la devoluci√≥n?")
        print("1. S√≠, entregado despu√©s de la fecha")
        print("2. No, entregado a tiempo")
        
        retraso_opcion = self.obtener_entrada("Seleccione opci√≥n", int)
        
        if retraso_opcion == 1:
            dias_retraso = self.obtener_entrada("D√≠as de retraso", int)
            fecha_devolucion = prestamo.get_fecha_limite() + timedelta(days=dias_retraso)
        else:
            fecha_devolucion = None  # Usar√° fecha actual
        
        id_trans = self.obtener_entrada("ID de devoluci√≥n (ej: DEV001)")
        
        try:
            devolucion = Devolucion(id_trans, prestamo.get_usuario(), 
                                   prestamo.get_material(), prestamo, estado)
            
            # Configurar fecha de devoluci√≥n si hay retraso
            if retraso_opcion == 1:
                devolucion._Devolucion__fecha_devolucion = fecha_devolucion
            
            if devolucion.procesar_transaccion():
                self.transacciones.append(devolucion)
                
                print(f"\n‚úÖ DEVOLUCI√ìN REGISTRADA")
                print(f"   Pr√©stamo: {prestamo.get_id_transaccion()}")
                print(f"   Estado material: {estado}")
                print(f"   Fecha devoluci√≥n: {devolucion.get_fecha_devolucion().strftime('%d/%m/%Y')}")
                
                if devolucion.tiene_multa():
                    multa = devolucion.calcular_costo()
                    print(f"   ‚ö†Ô∏è  MULTA POR RETRASO: ${multa:.2f}")
                    print(f"   D√≠as retraso: {prestamo.get_dias_retraso()}")
                    print(f"   C√°lculo: {prestamo.get_dias_retraso()} d√≠as √ó $0.50 = ${multa:.2f}")
                else:
                    print(f"   ‚úÖ Sin multa")
                    
            else:
                print("‚ùå NO SE PUDO REGISTRAR LA DEVOLUCI√ìN")
                
        except Exception as e:
            print(f"‚ùå Error: {e}")
    
    def ver_transacciones(self):
        if not self.transacciones:
            print("\nüì≠ No hay transacciones registradas.")
            return
        
        print("\n" + "="*80)
        print("üíº LISTA DE TRANSACCIONES")
        print("="*80)
        
        # Agrupar por tipo
        tipos = {}
        for trans in self.transacciones:
            tipo = trans.__class__.__name__
            if tipo not in tipos:
                tipos[tipo] = []
            tipos[tipo].append(trans)
        
        for tipo, lista in tipos.items():
            print(f"\nüìã {tipo.upper()} ({len(lista)}):")
            for i, trans in enumerate(lista, 1):
                print(f"  {i}. {trans}")
        
        print("-"*80)
        print(f"Total: {len(self.transacciones)} transacciones")
    
    def calcular_costos(self):
        if not self.transacciones:
            print("\nüì≠ No hay transacciones para calcular.")
            return
        
        print("\n" + "="*60)
        print("üí∞ C√ÅLCULO DE COSTOS Y MULTAS")
        print("="*60)
        
        total_general = 0
        multas_totales = 0
        
        for trans in self.transacciones:
            costo = trans.calcular_costo()
            total_general += costo
            
            if isinstance(trans, Devolucion) and trans.tiene_multa():
                multas_totales += costo
            
            print(f"\n{trans.__class__.__name__} {trans.get_id_transaccion()}:")
            print(f"  Estado: {trans.get_estado()}")
            print(f"  Costo: ${costo:.2f}")
            
            if isinstance(trans, Prestamo):
                print(f"  Fecha l√≠mite: {trans.get_fecha_limite().strftime('%d/%m/%Y')}")
                if trans.get_dias_retraso() > 0:
                    print(f"  D√≠as retraso: {trans.get_dias_retraso()}")
        
        print("\n" + "-"*60)
        print(f"üìä RESUMEN FINANCIERO:")
        print(f"  Total general: ${total_general:.2f}")
        print(f"  Total multas: ${multas_totales:.2f}")
        print(f"  Ingresos por pr√©stamos: ${total_general - multas_totales:.2f}")
    
    def demostrar_polimorfismo(self):
        if not self.transacciones:
            print("\nüì≠ No hay transacciones para demostrar.")
            return
        
        print("\n" + "="*60)
        print("üéØ DEMOSTRACI√ìN DE POLIMORFISMO")
        print("="*60)
        print("Mismo m√©todo procesar_transaccion(), diferentes comportamientos:")
        print("-"*60)
        
        for trans in self.transacciones[:3]:  # Mostrar solo 3 ejemplos
            clase = trans.__class__.__name__
            estado_inicial = trans.get_estado()
            
            print(f"\n{classe}:")
            print(f"  Estado actual: {estado_inicial}")
            print(f"  Costo actual: ${trans.calcular_costo():.2f}")
        
        print("\n" + "-"*60)
        print("Mismo m√©todo calcular_costo(), diferentes f√≥rmulas:")
        print("-"*60)
        
        # Crear ejemplos para mostrar
        ejemplos = []
        try:
            if self.usuarios and self.materiales:
                # Ejemplo de pr√©stamo
                p = Prestamo("EJ_P", self.usuarios[0], self.materiales[0])
                p.procesar_transaccion()
                ejemplos.append(("Pr√©stamo", p.calcular_costo(), "costo base"))
                
                # Ejemplo de renovaci√≥n
                r = Renovacion("EJ_R", self.usuarios[0], self.materiales[0], p)
                r.procesar_transaccion()
                ejemplos.append(("Renovaci√≥n", r.calcular_costo(), "50% descuento"))
                
                # Ejemplo de reserva
                res = Reserva("EJ_RES", self.usuarios[0], self.materiales[0])
                res.procesar_transaccion()
                ejemplos.append(("Reserva", res.calcular_costo(), "gratis"))
                
                # Ejemplo de devoluci√≥n con multa
                p2 = Prestamo("EJ_P2", self.usuarios[0], self.materiales[0])
                p2.procesar_transaccion()
                # Simular retraso
                p2._Prestamo__fecha_devolucion_real = p2.get_fecha_limite() + timedelta(days=3)
                p2._Prestamo__dias_retraso = 3
                d = Devolucion("EJ_D", self.usuarios[0], self.materiales[0], p2)
                d.procesar_transaccion()
                ejemplos.append(("Devoluci√≥n", d.calcular_costo(), "multa por retraso"))
                
                for nombre, costo, desc in ejemplos:
                    print(f"{nombre:12} ‚Üí ${costo:6.2f} ({desc})")
                    
        except Exception as e:
            print(f"Error en demostraci√≥n: {e}")
    
    def demostrar_encapsulamiento(self):
        print("\n" + "="*60)
        print("üîí DEMOSTRACI√ìN DE ENCAPSULAMIENTO")
        print("="*60)
        
        if not self.transacciones:
            print("‚ùå No hay transacciones para demostrar")
            return
        
        trans = self.transacciones[0]
        
        print("1. Intentando acceder a atributos privados directamente:")
        print("   trans.__id_transaccion ‚Üí Generar√° AttributeError")
        
        try:
            print(f"   Intento: {trans.__id_transaccion}")
        except AttributeError:
            print("   ‚úÖ CORRECTO: AttributeError al acceder a __id_transaccion")
        
        print("\n2. Usando getters y setters con validaci√≥n:")
        print(f"   Estado actual: {trans.get_estado()}")
        
        # Intentar asignar estado inv√°lido
        try:
            trans.set_estado("estado_invalido")
        except ValueError as e:
            print(f"   ‚ùå Setter bloquea estado inv√°lido: {e}")
        
        # Asignar estado v√°lido
        try:
            trans.set_estado("completada")
            print(f"   ‚úÖ Setter acepta estado v√°lido: {trans.get_estado()}")
        except ValueError as e:
            print(f"   ‚ùå Error: {e}")
        
        print("\n3. M√©todos privados internos:")
        if isinstance(trans, Prestamo):
            print("   Prestamo tiene m√©todo _calcular_multa() privado")
            print("   Solo se usa internamente al calcular costos")
    
    def simular_ciclo_completo(self):
        print("\n" + "="*60)
        print("üìä SIMULACI√ìN DE CICLO COMPLETO")
        print("="*60)
        print("Demostrando el flujo completo:")
        print("1. Reserva ‚Üí 2. Pr√©stamo ‚Üí 3. Renovaci√≥n ‚Üí 4. Devoluci√≥n")
        print("-"*60)
        
        try:
            if not self.usuarios or not self.materiales:
                print("‚ùå Faltan datos de usuario o material")
                return
            
            usuario = self.usuarios[0]
            material = self.materiales[0]
            
            print(f"\nüë§ Usuario: {usuario.get_nombre()}")
            print(f"üìö Material: {material.get_titulo()}")
            print("-"*40)
            
            # 1. RESERVA
            print("\n1. üïê CREANDO RESERVA...")
            reserva = Reserva("SIM-RES", usuario, material)
            reserva.procesar_transaccion()
            self.transacciones.append(reserva)
            print(f"   ‚úÖ Reserva creada: {reserva}")
            print(f"   Costo: ${reserva.calcular_costo():.2f}")
            
            # 2. PR√âSTAMO
            print("\n2. üìñ CREANDO PR√âSTAMO...")
            prestamo = Prestamo("SIM-PRE", usuario, material)
            resultado = prestamo.procesar_transaccion()
            self.transacciones.append(prestamo)
            print(f"   ‚úÖ Pr√©stamo creado: {prestamo}")
            print(f"   Aprobado: {resultado}")
            print(f"   Fecha l√≠mite: {prestamo.get_fecha_limite().strftime('%d/%m/%Y')}")
            print(f"   Costo base: ${prestamo.calcular_costo():.2f}")
            
            # 3. RENOVACI√ìN
            print("\n3. üîÑ CREANDO RENOVACI√ìN...")
            renovacion = Renovacion("SIM-REN", usuario, material, prestamo)
            resultado_ren = renovacion.procesar_transaccion()
            self.transacciones.append(renovacion)
            print(f"   ‚úÖ Renovaci√≥n creada: {renovacion}")
            print(f"   Aprobada: {resultado_ren}")
            print(f"   Nueva fecha l√≠mite: {renovacion.get_nueva_fecha_limite().strftime('%d/%m/%Y')}")
            print(f"   Costo con descuento: ${renovacion.calcular_costo():.2f}")
            
            # 4. DEVOLUCI√ìN CON RETRASO
            print("\n4. üìÖ REGISTRANDO DEVOLUCI√ìN CON RETRASO...")
            # Simular 2 d√≠as de retraso
            fecha_devolucion = prestamo.get_fecha_limite() + timedelta(days=2)
            devolucion = Devolucion("SIM-DEV", usuario, material, prestamo)
            devolucion._Devolucion__fecha_devolucion = fecha_devolucion
            devolucion.procesar_transaccion()
            self.transacciones.append(devolucion)
            print(f"   ‚úÖ Devoluci√≥n registrada: {devolucion}")
            print(f"   D√≠as retraso: {prestamo.get_dias_retraso()}")
            print(f"   Multa calculada: ${devolucion.calcular_costo():.2f}")
            print(f"   C√°lculo: {prestamo.get_dias_retraso()} d√≠as √ó $0.50 = ${devolucion.calcular_costo():.2f}")
            
            print("\n" + "="*60)
            print("üéâ CICLO COMPLETADO EXITOSAMENTE")
            print("="*60)
            print(f"Total transacciones creadas: 4")
            print(f"Costo total del ciclo: ${reserva.calcular_costo() + prestamo.calcular_costo() + renovacion.calcular_costo() + devolucion.calcular_costo():.2f}")
            
        except Exception as e:
            print(f"‚ùå Error en simulaci√≥n: {e}")
    
    def ejecutar(self):
        while True:
            self.mostrar_menu_principal()
            opcion = self.obtener_entrada("Seleccione una opci√≥n", int)
            
            if opcion == 0:
                print("\nüëã ¬°Gracias por usar el sistema de transacciones!")
                break
            
            elif opcion == 1:
                self.crear_prestamo()
            
            elif opcion == 2:
                self.crear_renovacion()
            
            elif opcion == 3:
                self.crear_reserva()
            
            elif opcion == 4:
                self.registrar_devolucion()
            
            elif opcion == 5:
                self.ver_transacciones()
            
            elif opcion == 6:
                self.calcular_costos()
            
            elif opcion == 7:
                self.demostrar_polimorfismo()
            
            elif opcion == 8:
                self.demostrar_encapsulamiento()
            
            elif opcion == 9:
                self.simular_ciclo_completo()
            
            else:
                print("‚ùå Opci√≥n inv√°lida")
            
            if opcion != 0:
                input("\n‚èé Presione Enter para continuar...")

# ========== PROGRAMA PRINCIPAL ==========
if __name__ == "__main__":
    print("="*60)
    print("EJERCICIO 1.3: SISTEMA DE PR√âSTAMOS Y DEVOLUCIONES")
    print("="*60)
    
    # Demostrar que no se puede instanciar clase abstracta
    print("\nüîç Demostrando ABSTRACCI√ìN:")
    try:
        # Intentar crear objeto de clase abstracta
        # Necesitamos usuario y material de ejemplo
        from ejercicio_1_1_menu import LibroFisico
        from ejercicio_1_2_menu import Estudiante
        
        usuario_ej = Estudiante("Test", "123", "test@email.com", "Test", 1)
        material_ej = LibroFisico("Test", "Autor", 2023, "TEST", 100, "Ed", "bueno")
        
        transaccion = Transaccion("TEST", usuario_ej, material_ej)
        print("‚ùå ERROR: No deber√≠a poder instanciarse")
    except NotImplementedError as e:
        print(f"‚úÖ CORRECTO: No se puede instanciar Transaccion base")
        print(f"   Error: {e}")
    except ImportError:
        print("‚ö†Ô∏è  No se pudieron importar clases necesarias para la demostraci√≥n")
    
    input("\n‚èé Presione Enter para iniciar el sistema interactivo...")
    
    # Iniciar men√∫ interactivo
    sistema = MenuTransacciones()
    sistema.ejecutar()
